const vsh_src = `
precision highp float; 
#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))
const float PI = asin(1.) * 2.; const float EPSILON = 0.01; const float FAR = 12.; uniform float u_time; uniform vec2 resolution; uniform float rightEye; varying vec2 v_tex_coord; float df_sphere(vec3 p, float s) { return length(p) - s; } float scene(vec3 p) { float d = FAR; d = min(d, df_sphere(p + vec3(0., .5, 0.), 1.)); d = min(d, df_sphere(p + vec3(0., -.5, -2.), .5)); d = min(d, df_sphere(p + vec3(-sqrt(3.), -.5, 1.), .5)); d = min(d, df_sphere(p + vec3(sqrt(3.), -.5, 1.), .5)); return d; } float lighting(vec3 p, vec3 src) { vec3 e = normalize(src - p) * EPSILON / 2.; return (scene(p + e) - scene(p - e)) / EPSILON; } void main() { gl_FragColor = vec2(0., 1.).xxxy; if (mod(gl_FragCoord.x+gl_FragCoord.y, 4.)>0.) return; vec2 uv = vec2(1., -.5) * (v_tex_coord - .5) * resolution / resolution.x + .5; if (abs(uv.y - .5) > .5) return; float which = step(uv.y, .5); vec3 cam = vec3(0., 0., 5. + 5. * which); vec3 tgt = vec3(0., 0., 0.); cam.yz *= rot(-cos(u_time / 2. + 2. * which) * PI / 6. + PI / 6. * which); cam.xz *= rot(u_time * (2. * which - 1.)); vec3 front = normalize(tgt - cam); vec3 right = normalize(cross(front, vec3(0., 1., 0.))); vec3 up = cross(right, front); uv = fract(uv * vec2(1., 2.)) - .5; vec3 dir = normalize(front * 1. + right * uv.x + up * uv.y); float eye = (rightEye - .5); cam += right * eye; float dist = 0.; float d = 0.; for (int i = 0; i < 30; i++) { d = scene(cam + dist * dir); dist += d; if (d < EPSILON || dist > FAR) break; } float n = 0.; if (d < EPSILON) { n = max(0., lighting(cam + dist * dir, vec3(-4.))) + .2; } //float n = 1. - .2 * dist; gl_FragColor = vec2(n, 1.).xxxy; if (length(cam + dist * dir + vec3(0., .5, 0.)) > 1. + EPSILON) gl_FragColor.rg *= .5; else gl_FragColor.gb *= .5; //gl_FragColor = vec4(uv.x, 0., uv.y, 1.); //gl_FragColor.rgb = 1. - clamp(gl_FragColor.rgb, vec3(0.), vec3(1.)) * 1.; }
`;
